A kernel is the fundamental core of a computer's operating system (OS), acting as a bridge between hardware and software to manage system resources like CPU, memory, and devices. It handles crucial tasks such as process scheduling, memory management, and input/output (I/O) requests, ensuring all components work together efficiently and securely. 

what is firmware is simple and complex terms
ChatGPT said:
Simple Definition of Firmware:

Firmware is a type of software that is permanently stored in a device's memory and provides low-level control for the device's hardware. It tells the device how to operate and interacts directly with the hardware, allowing it to perform its basic functions. Unlike regular software, firmware is "built-in" and typically doesn't get updated often (although it can be updated in some cases).

For example:

In a microwave, firmware controls the timer, the buttons, and the display.

In a smartphone, firmware controls the basic functions like turning the screen on/off or controlling the camera hardware.

Complex Definition of Firmware:

Firmware refers to specialized software that is embedded within hardware devices to control and manage their functions. It is stored in non-volatile memory (such as ROM, flash memory, or EEPROM) and provides the foundational instructions for hardware operation, often at a low level. It can operate directly with the device's hardware (e.g., CPU, sensors, display) and enables higher-level software to interact with the hardware effectively.

Firmware can range from simple control routines in embedded systems (e.g., microcontrollers) to more sophisticated systems like BIOS (Basic Input/Output System) or UEFI (Unified Extensible Firmware Interface) in personal computers, which manage hardware initialization during the boot process.

Firmware is typically designed to be optimized for the specific hardware it runs on, and its updates, when they occur, often fix bugs or improve performance without altering the overall functionality of the device. In some cases, firmware can also facilitate device-specific security features and hardware-level encryption.

Examples:

Embedded Systems: Microcontrollers and programmable logic devices (PLDs) running control loops, sensor data processing, or even embedded operating systems (RTOS).

Consumer Electronics: Embedded firmware in digital cameras, routers, smart TVs, or printers.

Computers: The BIOS/UEFI is a form of firmware responsible for the initial hardware checks during boot-up, initialization of essential peripherals, and passing control to the operating system.

Key Characteristics of Firmware:

Non-Volatile: It stays in memory even when the device is powered off.

Low-Level: It directly interfaces with hardware and is often written in low-level programming languages like assembly.

Specialized: It’s tailored for the specific hardware it controls.

Updates: Though firmware is generally stable, it can be updated to fix bugs or add features.

To summarize:

Simple terms: Firmware is like the "brain" of your device that tells it what to do with its hardware, and it’s built right into the device.

Complex terms: Firmware is low-level software that directly interacts with and controls a device's hardware, enabling basic operations and potentially interacting with higher-level software. It is often stored in non-volatile memory and optimized for specific devices.

You said:
so is firmware kernel?
ChatGPT said:

Great question — and no, firmware is not the same as the kernel, though they are both essential parts of a computer or embedded system.

Let's break it down clearly:

✅ Firmware vs Kernel — Key Differences
Feature	Firmware	Kernel
What it is	Low-level software embedded in hardware	Core part of the operating system
Where it runs	On the hardware itself, often before the OS loads	In system memory, after bootloader runs it
Purpose	Initializes hardware, enables basic control	Manages system resources (CPU, memory, devices)
When it runs	Very early in the boot process	After firmware and bootloader, as part of the OS
Example	BIOS/UEFI, microcontroller firmware in a toaster	Linux kernel, Windows NT kernel
Updatability	Rarely updated, specific to hardware	Frequently updated as part of OS upgrades
🧠 How They Work Together (Boot Sequence Example)

Firmware (e.g., BIOS/UEFI) starts first.

Initializes the CPU, memory, and hardware.

Checks devices (POST).

Finds the boot device and loads the bootloader.

Bootloader (e.g., GRUB, U-Boot) is loaded next.

Its job is to find and load the kernel.

Kernel (e.g., Linux, Windows kernel) is then loaded by the bootloader.

Takes over full control of the system.

Sets up drivers, memory management, process scheduling, etc.

Launches the user space (the rest of the OS).

🛠️ Real-World Analogy

Think of a computer like a car:

Firmware = the ignition system — it wakes everything up and gets things ready.

Kernel = the engine control system — it runs the car once it’s started, managing fuel, speed, brakes, etc




The serveice is a program that runs as a background process  
File System is the method for storing and organizing the files in the system


Xwindow system  provides the toolkit and standard protocals for building guis on nearly all linux sstems

Desktop environment is the GUI on top of the operating system 
Command line is the interface for typing commands on top of the OS

Shell is the commandline interpreter that interpretes the commandlineinput and instructs the system to perform any neccesary tasks and commands eg. bash, zsh, and tcsh


LINUX DISTRIBUTIONS
Network and services protocalas known as daemons long runing background processes httpd ect ends with d 

LINUX BASICS AND SYSTEM STARTUP
Linux boot process is the procedure for starting the system from when the user switches on to the point where the computer is operational

BIOS: The first step (Basic Input output system)
initializes the screen and keyboard and tests the main memory BIOS is stored on the ROM chip in the motehrboard Then after the boot process is controlled by teh OS 

Once POST is done the boot control is passed from the BIOS to the bootloader and is eithere sored in the ootsector in the MBR or  in UEFI(Unified Extensible Firmware Interface)

Both UEFI and BIOS are types of firmware—software that’s built into your computer’s hardware to help it start up and manage basic functions before the operating system loads



The bootloader can give ou the otions to like GRUB, 
For the system residing in MBR the boorloader is stored in the first sector of the harddisk (aLSO KNOWN AS the maste boot record)
=> the sixe of MBR is 512Bytes


For UFI/UEFI it reads it uefi boot manager to determine which uefi appplication is to be launhed  and from where, The firmware then lauches UEFI application like RUB as definied by the bootentry in the frimware boot manager and then after choosing the os the bootloader load the kernel o the operating system into RAM and passes control to it.

KErnels are always compressed so the first josb is alwas to uncompress itself and after this it will notoalize the device hardware and drivers built in the systems' kernel


INITIAL RAM DISK

The init ram/fs file image contais programs and binariy files that perform all actions needed to mount the proper file syetem like provinding the proper kernelfunctionalitiesn for the need file syetem and devicae drivers for mass storeage controllers  with a facility called UDEV for user device whic is reposible for figuring out which devices are present locating the device drivers they need to operate properly and loading them, 

After the root file system has been found   its checked for errors then mounted Thenafter it istructs the OS the file sytems is ready fo use and it associates it with that particular poitn in the hierrachy file system the mount point

If this is succesiful the Init ram fs is cleared from rAM fs and the init program from the root system is executed 

INIT handles the mounting and pivoting to the final real root system, if special harware drives are needed bfore the mass storage can be acessed they must be in the init ram fs image 


TEXT_LOGIN MODE
In the end of the boot process init start a number of text mode prompts these enable you to type your username followe by ur pswrd and to eventually get the command shell 

HOWEVER 
if u are running a GUI several you wont see these comand at first

usually the commandshell is bash The shell prints command shell indicating its ready to receive commands, when a command is typed its executes and the other command is printed/displayed beau:)

THE INUX KERNEL
The bootloader load the INITram and kernel so that it can be used by the kernel, when loaded in ram it initializes and configures the computer's memory it also configures all the harware attached to the system, including processors, IO subsysems, storage devices and more also loads the userspace applocations 


/sbin/init and services
after the kernel is done with all that the te kernel run that folder and this beocmes te initial/parent process and then start othe procvesses to get the system running, In the exeptions of the kernel processes most processes start from the /sbin /init

apart form starting the system it keep  the system running and its important fot shutting the system cleanly
=> manages the background processes and the login logut services as needed and does the same for the backeground processes
this ssequenial run level method which is originally by the unix V, is outdated though its is emulated for compatibility purposes and other methods are currently used

New methods of sytemd which have become dominant

systemd
startup faster than those with init methods, this is because it replaces the serialiced methods with parallel methods which permits multiple methods to be initiated simulatineously

Note: now /sbin/init now points to /lib/systemd/systemd


systemctl usage
=> starting, stopping and restarting aservice (using httpd, Apache webserver as an esample) on a concurrrenly runnig system
$ sudo start|stop|restart httpd.service

Enabling or disabling a system service from string up at the system boot
$ sudo systemctl andble|disable httpd.service



LINUX FILE SYSTEM BASICS
File systems suppoterd by Linux include:
=> COnvectionsl file systems ext2,3 XFS, BTRFS JFS, NTFS, vfat etc
=>flash storage system
=> Database file system
=> special file system



PARTITIONS AND FILE SYSTEMS
A partitions is a physically contiguous section of the disk or what appears to be so in advanced dsetups 

A file system is method od storing or finding files on a harddisk file systems can span more than one partition if one uses symbolic links




CMPRSON BTN FILE SYSTEMS
/dev/sda1 partition
Base folder / and in windows c:\

The file system HIERRACHY (FHS) standard
Linux stores their important files in a standard layout called  that name above 

/bin/ - Esssential user command binaries
/boot/- static files of the bootloader
/dev/- devic files
/etc/- Host-speciefic system configurationrequired directories OPT, XIML, 
/home/- user home directories
/lib/- essential sared libraries and kernel modules
/media/- mount point for rmovable media
/mnt/- mount point for a temporary mounted file system
/opt/- add-on application softaware packages
/sbin/- systm binaries
/srv/- data for services provided in this system 
/tmp/- temporary files
/usr/- multi user utulities and applications
/var/-variable files 
/proc/- virtual file system documenting the kernel and process status as text files 
/root/- home directory for the root user

End of chpter 3
CHAPTER 04: Graphical interface:
The x-windows system is loaded as one of the final process in the boot process often called x and the   the desktop manager keeps track of the displays being provided and loads the x server so called because it provides the graphical services to applications. sometimes called the x client, due to security concerns it is slowly replaced by wayland and it looks just like x but with different impelementation under the hood.


Reference: impelementation of the wayland server

Desktop environment consists of: 
=> Session manager -starts and maintains the session of the graphical component

=> Window manager - controls the placement and position of the window title bars and controls
=> Set of utilities all these provide a seamless desktop environment

Gnomeis the popular desktop environment and its bundled as the default environment for most linux distributions

another de and important in the history of linux is kde


gnome-tweaks
you can pull this by hittind ctrl f2 and it is mostly instaled by default 

Hidden files are configuration files that are hidden by default

the gdm user manager prsents the user with the login screen


Logging out kill all the processes in your current session and returns to the display manager login screen

Suspending puts the computer in a sleep mode
Every user created will have the home directory

Nautllus gives you three options to view files
Nautilus file manager was developed by Eazel, a now-defunct company:

Founded in 1999 by former Apple engineers.

Their vision was to make Linux more user-friendly, starting with the GNOME file manager.

Eazel named the project Nautilus — likely blending both the biological and literary meanings


System configuratiosn from the GUI
=> Use system settings panel
=> Use network manager
=> Install and update software

By defal linux uses coordinated universal time and that relies on the system time zones to get the proper time
UTC vs GMT – Super TL;DR

UTC = modern, precise time standard (used globally)

GMT = older, UK-based time zone

Both = same time, but UTC is more accurate and preferred today ✅

Network time protocal
Important and relible ip for ssetting time by consulting established servers, Lnux distributions always comes with a working NTP setup 


Network configuration 
All linux distros haave nc files

For debian systems dpkg is the underlying package manager for the system can istall remove and build packages
Apt-advanced package tool
apt respositiories are compatible, developers ship with mulriple repostories to support multiple distributions

Rpt= redhat package tool 
yast= is another application management tool



COMMON LINUX APPLICATIONS:
yapping nothing much

COMMAND LINE OPERATIONS:
advantages:
no GUI overhead is incurred
virtually any task can be accomplished at the command line argument
You can impelement scripts for often used (or easy to forget) tasks and a series of procedures
You can signi in in any remote machines over the internet
You can initiate graphical applications through cml  instead of hunting through menus
While graphical tools may vary through sidtributions the commandline dont

Utility software is a program or tool that performs specific tasks to enhance productivity, efficiency, functionality, or maintenance of a computer system.





You can hit alt f2 and type in gnome-terminal or konsole
cat => used to type in a file
head => show in the first few lines of a file
tail=> use to show last few lines of a file
man=> used to view documentation


THE COMMND LINE

Important parts of a command
command -options arguments
ls      -a       /home/angela 

the options often start with either a single or double dashes

sudo
provides the user with administrative privilleges when reqired
setting up and running sudo in your system
type "su" and enter password 
create a config file on etc/sudoers.d/ with the same name as your username
eg. echo "student ALL = (ALL)" > etc/sudoers.d/student

some distributions will complain if you dont change permissions on the fileby doing chmod 440 etc/sudoers.d/student

VIRTUAL TERMINALS
To launch a virtual eminal press ctrl+alt+f(1 to 6) and enter username and password
There a 6 virtual terminals on linux
Terminal Type (TTY): In computer systems, TTY may refer to a terminal that communicates with a computer. It's shorthand for the terminal interface on Unix-like systems, where a "tty" device represents a physical or virtual terminal.

ctrld- log you out of the terminal
ctrl alt del will reboot the system

reset- clears out the terminal 
home- takes you at the beginning of the line
end- will take you to the end of it
ctrl+alt+f7 will take you to the terminal on desktop kind of 

You can stop the desktop gui
sudo systemctrl stop gdm 
and star with sudo systemctl start gdm or sudo telinit 5

shut down -r for reboot and -h for halt

example sudo shutdown -h 10:00 "shutting down for maintanance"


Users applications can be located at /bin or /usr/bin/ or /sbin /usr/sbin
or somewhere under /opt or /usr/local/bin or usr/local/sbin

or in a users account space /student/home/bin

one of teh ways to locate programs is to employ the which utility or you can use whereis

to get the exact location of your home dorectory you can use echo $HOME
cd ~ change to home directory
cd - change directory to previous one

pwd- print working directory

pushd - take you tothe direct you want
popd - takes you to previous dir

Absolute paths=> Starts from the root dir and goes branch by branch until it reaches the desired file or dir
Relative paths=> Starts from the present directory mutiple slashes are ignored by the system eg. /////usr//bin === user/bin

. present direvory
.. parent directory
~ home directory

tree -d to view the directories while supressing te names
 cd / => changes the current directpry to the root directry

ln source_file  destination_file is used to make hard link

ln -s  source_file  destination_file use to make symbolic links or softlinks

📋 Most Common ls Flags
Flag	Description	Example
-l	Long listing format (shows permissions, owner, size, etc.)	ls -l
-a	Show all files, including hidden files (those starting with .)	ls -a
-la or -al	Combine -l and -a – long list including hidden files	ls -la
-h	Human-readable file sizes (used with -l)	ls -lh
-R	Recursive listing (list subdirectories too)	ls -R
-t	Sort by modification time (newest first)	ls -lt
-r	Reverse the sort order (can be combined with other flags)	ls -ltr
-S	Sort by file size (largest first)	ls -lS
-d	List directories themselves, not their contents	ls -d */
--color=auto	Colorize output (usually enabled by default)	ls --color=aut



List of directories is shown with dirs command
!! => will run he laast command

pushd + 1 etc switches between available dirs in the stack

wc => wordcount command
less=> shows once screen at a time if you use less -N it shows with numbers
if you want small number use head and tail  for th buttom text use -10, -20 for the number of lines you eactly want

touch can be used to reset the timestamp also to create empty files

with -t options allows you to provide the speciefic date and time

to remove the directory with its contents use rm -rf

rm -i to promp interactively before removal

MODIFYING THE COMMNDLINE
PS1 variable is the one used to customize the prompt name

mv can beused to rename a file 
mv filename newfilename to view ls -l *file*

STANDARD FILE STREAMS
IO redirect
$do something < input-file //if you want to app;y the input to a command
$do something > output-file  //if you want to get the output to a file


If you want to send the erro messages to the file you can use the descriptor followed by a greater than symbol eg.
$ do-something 2> error-file


$ do-something > all-output-file 2>&1

simpler syntax in bash

$ do-something >& all-output-file 


PIPES
You can pipe the output of one command to be the input of another eg 
$ command | command | commmand

Advantage=> the output input can be streamed and there is no need to wait for one command to compelete execution and he other is there is no need to save the files in the intermediary files and hence reduce reading and writing from disk which is the bottleneck of getting something done

SEArCHING FOR FILES
the tools are locate and find also wildcard which gives the generalized result of the request

eg locate zip | grep bin 
locate uses update db and its updated once and you can manually update it by running that command 

find . -name "LF300" -ls

echo > filename creates an empty filename

find will find the newly added file whilst the locate wont until you updatebd by:
$ sudo updatedb

using wildcards
?if you know the few letters
*matches any string of characters
[set] => matches any characters in the set of characters for example [adf] will match any occurrence of a,d,f

 [!set] => matches any character not in the set of charaters

du -h	Human-readable sizes (KB, MB, GB)
du -sh	Total size of current dir (summary + readable)
du -sh *	Show size of each item in current dir
du -ah	Show size of all files and folders (readable)
du -d 1 -h	Show size of directories one level deep
du -csh	Show total size and a final grand total
du --max-depth=2 -h	Show size up to 2 levels deep












File Searching & Wildcards in Linux – TL;DR
✅ 1. Wildcards (Globbing)
Wildcard	Matches	Example
*	Zero or more characters	ls *.txt → all .txt files
?	Exactly one character	ls file?.txt → file1.txt, fileA.txt
[...]	Any one character in brackets	ls file[123].txt → file1.txt, file2.txt
{a,b}	Matches either a or b	ls {file1,file2}.txt
🔎 2. Find Files (find)

Basic syntax:

find [path] [options] [expression]

Command	Description
find . -name "*.txt"	Find .txt files in current dir & subdirs
find /home -type d -name "books"	Find directories named books
find . -iname "*.jpg"	Case-insensitive search for .jpg files
find . -size +100M	Files larger than 100 MB
find . -mtime -3	Files modified in the last 3 days
find . -type f -empty	Empty files
🧵 3. Search File Contents (grep)
Command	Description
grep "hello" file.txt	Find "hello" in a file
grep -i "hello" file.txt	Case-insensitive search
grep -r "hello" .	Recursive search in current dir
grep -rn "hello" .	Recursive + show line numbers
grep -rl "hello" .	Recursive + show filenames only
grep --color=auto "word" file	Highlight matches
🔧 Combine with Wildcards

Search all .log files for "error":

grep "error" *.log


Find all .sh scripts and search for sudo:

find . -name "*.sh" -exec grep -H "sudo" {} \;


Want a cheat sheet image or advanced usage (like find with xargs, or grep with regex)? Just say the word.

find can be used with -name -type -l for symbolic links or f for a regular file

The -exec option in the find command is used to run a specified command on each file or directory that matches the search criteria. For example, find . -name "gcc" -exec rm {} \; searches for files named "gcc" starting from the current directory and deletes each one using rm. The {} is a placeholder for the current file found, and \; signifies the end of the -exec command. If you want better performance, you can replace \; with +, which tells find to pass all matching files to the command in one go (e.g., find . -name "*.log" -exec rm {} +). To exclude files, you don't need -exec; instead, you can use ! -name or -not (e.g., find . -type f ! -name "*.log"). However, you can combine both exclude and exec by writing something like find . -type f ! -name "*.log" -exec rm {} \; to delete all files except those ending in .log.

you can end the command with \; or ;

find will prompt you for the confirmation before will executing the command

 


ended at 3:00:00

Finding files based on time and size
-ctime when time metadata was changed not neccesarily when they were created or written
$ find / -ctime 3

based on sizes use find / -size 0 size here is in 512 block by default for details consult the man pages for find
there is -ls built on find

Package MANAGEMENT SYSTEMS ON LINUX
both package managers operate on 2 distinct levels a low level tool such as dpkg and rpm  higlevel like apt--get zypper and yum  downloads and figures out dependencies
the high level tool will work eith the low level tool and call it as needed 

dependency resolution is an important feature of the high kevel tools


WORking WITH DIFFERENt package mangement tools
apt-get => for debian systems
dnf=> manages packages for RHEL fedora and RHEL 8 replaced their yum utility with dnf there by eliminating a lot of historical baggage while introducing many nice capabilities dmf id backward compatible with yum 

zypper is a pm for suse or open suse family  and it is also based on rpm
for debian based systems you just use apt-get --install package.foo  apt-get --autoremove package.foo  
dpkg --install package.foo 
dpkg --remove package.foo 

apt-get dist-upgrade
dpkg --list 

CHAPTER 8: FINDING LINUX DOCUMENTATION
DOC sources:
=> man pages
=> GNU info
=> command help
=> other documentation help
To use GNU info you just type in info and then then the keyword if the info you wnat to get

the --help you cna just typein the command and then typw in --help


synopsis
/sɪˈnɒpsɪs/
noun
a brief summary or general survey of something.

Other documentation sources:
=>desmtop help system
=> package documentation
=> Online resources



CHAPTER 9: PROCESSES
A process is an instance of 1 or more related tasks  or threads executing on your computer, its not a program or command, actually a single command can start several processes simulatinously 
Some processes are independent if each other and some are related 
Processes uses different system resources like ram nerwork cards mem etc

Process types:
processes can be atteched or detached runnign in the background 


types:
interactive processe=> need to be started by a user either via gui or commandline eg bash, firefox, top

batch process => Automatic processes which are schedules and then disconnected feom the terminal  eg updatedb and idconfig

daemons=> Server processes that runs continously sshd, httpd, libvirtd

threads=> Light processes that run under the ambrella of the main process, sharing memory or other resources firefox, gnime-terminal-server

lernel threads- Kernel tasks that a user neither starts nor terminates and have a littele control over eg kthread, migration, ksoftirqd



Process scheduling and states
The scheduler a critical part of the kernel switches on and off the cpu sharing time according to the priorty
a state can be in a runnig, waitstate(in a que waiting for to be given time by the scheduler) or zombie state(child compeleted but parent didnt ask for it, its not alive but still shows up in the system states)

Process and thread IDs
PID1 denotes the init process PID, PPID, TPI(same as the PID but for multiple processes, For multiple threas a process has the same PID but unique TID=> Thres ID number)

Terminating a process:
kill -SIGKILL <pid>
kill -9 <pid> 

You can only kill your own processes those by other uses are offlimits unless they are a root user

USER and GROUP IDs
RUID=> Identify the user who started the process 
RGIO=> isentifies the geoup that started the process
EUID-> derermines the access rights of the user
EGID -> determines acess rights of the group

Each user can be a member of one or more group
More about priorities
the priority of a process can be set by setting the niceness of the process
the max niceness val of 20 and lowest is 19 goes back to unix days 

Increasing the niceness lowers the priority

LOAD AVERAGES
is the average load number for a given period of time can be viewed by top w or uptime

example: load average: 0.45   .034  .012 
for the last (minute, 5minutes, 30 minutes) X time system has utuilized x pecentage of cpu


If you see the value of one means the average value of 100of the CPU has been utilized

BACKGROUND and FOREGROUND  processes
fg and bg to run the tings in the bacjgroung and foreground rspctively 

Managing jobs
job -l  usage dont show the jobs started from that terminal

ps -u user info about a specified username
ps -ef displays all the processes in details
ps -elf shows all the processes one line at a time


PS command (BSD style)
ps aux shows all the processes of all users
ps axo lets you specify the info you want to view

Process listed with [] were stated by the kernel and not started by the user

ps tree displays the procss tree and relations

top- gives you constant realtime update

i the load average has a number greater than 1 it means the processes are competing for the cpu time
if high might indicate a system is having a problem

atq is used to schedule the task in a series of commands 

cron:
is a time scheduling utlity program, can perform bakground tasks at speciefic times  on ongoing basis 
cron is driven by a configuration file called the cron table which contains the various commands which contains the commands which need to be run at speciefic times, and they can be system wide or userbased files

each line on the cron tab represents a job is represented by a cron expression followed by a command cron -e will let you edit the jobs

sleep => can sleep a process to wait for the dependent program or the other taks to compelete and will be executed later
 eg slee NUMBER[suffix]v suffixes can be S M D H 
sleep delays the execution for a certain period whole aqt starts the execution at a later time
Introduction to file systems
root directory is not the same as the root user
/bin => user binaries
/sbin => system binaries
/etc => configuration files
/dev => device files
/proc => process information 
/var => variable files
/tmp => temporary files
/usr => user programs
/home => home directories
/boot -> bootloader files
/lib -> system libraries
/opt -> optional libraries
/mnt -> mount directories
/media -> removable devices
/srv -> service data

Gparted utility which displays the parted layout of the partition of the system

lsblk-> shows which devices are connected to the system
If you mount the file on the system then the previous contents are covered up and you cant access them until the disk is umounted, thus mount points are usually empty directories
example:
$ sudo mount /dev/sda5 /home will attach that file into the system tree
to unmount:
$ sudo umount /home

only the root user have the previllege to run these commands
if you want the devices to be automatically mounted you have to configre the /etc/fstab accordingly

df -hT will show ou the mounted devices and he steps
NFS and Network file systems


comparing files with diff
 options: 
-c, -r  -i, -w, -q
to compare files
diff [options] <file1> <file2>
diff is used for text files and for binaries you can use cmp
FILE SYSTEM and its hierrachy 
File system archtecture
compare files and identify different files
using diff3 and patch
use can compare the files using diff3 where 1 file is used for reference for the other 2
for instance u and ur coworker started withe the same file and want to see the differences that you have made you can use diff3 example:

diff3 myfile common_file your_file

patching afile(esplain in details how it works)

use the file utility to determine the nature and all the infoemation about the file

cp can be used to copy paste files from source to destination with in the machine 
WHILE Rsync can be used to copy files from one machine to another
Only the differences are synchronized

example to backup the project:

$rsync -r projec-X archive-machine: archives/project-X

$rsynch sourcefile destinationfile and can be local to local or local to remote machine

File data is normally compressed to reduce disk space

zipping techniques vary depending on the size of the resulting file and the time it takes to compelete the zipping process
generally the efficient techniques takes longer 
Backup and compress data
